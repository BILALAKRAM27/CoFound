{% extends 'base.html' %}
{% load profile_filters %}

{% block title %}Messages - CoFound{% endblock %}
{% block extra_head %}
  <meta name="current-user-id" content="{{ request.user.id }}">
{% endblock %}

{% block styles %}
<style>
  /* Main container with proper height calculation */
  .content-container {
    padding: 0;
    margin: 0;
    height: calc(100vh - 120px);
    overflow: hidden;
  }

  .chat-container {
    display: grid;
    grid-template-columns: 320px 1fr;
    height: 100%;
    gap: 1rem;
    padding: 1rem;
    box-sizing: border-box;
  }

  /* Sidebar styling */
  .chat-sidebar {
    background: var(--bs-body-bg);
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    padding: 1rem;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.08);
  }

  .search-input-chat {
    border-radius: 8px;
    border: 1px solid #e2e8f0;
    transition: border-color 0.15s, box-shadow 0.15s;
  }

  .search-input-chat:focus {
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
  }

  .recents {
    flex: 1;
    overflow-y: auto;
    margin-top: 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 transparent;
  }

  .recents::-webkit-scrollbar {
    width: 6px;
  }

  .recents::-webkit-scrollbar-track {
    background: transparent;
  }

  .recents::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
  }

  .recent-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.15s ease;
    position: relative;
    margin-bottom: 0.25rem;
    border: 1px solid transparent;
  }

  .recent-item:hover {
    background: #f8fafc;
    border-color: #e2e8f0;
    transform: translateY(-1px);
  }

  .recent-item.active,
  .recent-item:active,
  .recent-item.selected {
    background: #e0e7ff;
    border-color: #c7d2fe;
  }

  .recent-item .avatar {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    object-fit: cover;
    background: #f3f4f6;
    border: 2px solid #e5e7eb;
    flex-shrink: 0;
  }

  .recent-item .unread-badge {
    background: #dc2626;
    color: #fff;
    font-size: 11px;
    font-weight: 600;
    border-radius: 12px;
    padding: 3px 8px;
    position: absolute;
    right: 12px;
    top: 12px;
    min-width: 20px;
    text-align: center;
    line-height: 1.2;
    box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3);
  }
  
  .recent-item .last-message-preview {
    color: #6b7280;
    font-size: 0.8rem;
    margin-top: 2px;
    line-height: 1.3;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 200px;
  }
  
  .recent-item .last-message-preview .bi-check2 {
    color: #2563eb;
    margin-right: 4px;
  }
  
  .recent-item .last-message-time {
    position: absolute;
    top: 12px;
    right: 12px;
    font-size: 11px;
    color: #9ca3af;
  }
  
  .recent-item.has-unread .last-message-time {
    top: 32px;
  }
  
  /* Privacy shield icon */
  .privacy-shield {
    color: #6b7280;
    margin-left: 4px;
    font-size: 12px;
  }

  /* Main chat area */
  .chat-main {
    background: var(--bs-body-bg);
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.08);
    position: relative;
  }

  .chat-header {
    padding: 1rem 1.25rem;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-shrink: 0;
    background: transparent;
    border-radius: 12px 12px 0 0;
  }

  .chat-header-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    background: #f3f4f6;
    border: 2px solid #e5e7eb;
    flex-shrink: 0;
  }

  .chat-header .avatar-placeholder {
    font-size: 1.5rem;
    color: #9ca3af;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  /* Messages area with proper scrolling */
  .chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    min-height: 0;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 transparent;
  }

  .chat-messages::-webkit-scrollbar {
    width: 6px;
  }

  .chat-messages::-webkit-scrollbar-track {
    background: transparent;
  }

  .chat-messages::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
  }

  /* Message bubbles with proper alignment */
  .bubble {
    max-width: 75%;
    padding: 0.75rem 1rem;
    border-radius: 18px;
    position: relative;
    word-wrap: break-word;
    word-break: break-word;
    line-height: 1.4;
    font-size: 14px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    margin-bottom: 4px;
  }

  /* Sender (outgoing messages - right side) */
  .bubble.sender {
    align-self: flex-end;
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    color: #ffffff;
    margin-left: auto;
    border-bottom-right-radius: 6px;
  }

  /* Receiver (incoming messages - left side) */
  .bubble.receiver {
    align-self: flex-start;
    background: #f8fafc;
    color: #1f2937;
    margin-right: auto;
    border: 1px solid #e2e8f0;
    border-bottom-left-radius: 6px;
  }

  /* Message status indicators */
  .message-status {
    position: absolute;
    bottom: -18px;
    right: 4px;
    font-size: 11px;
    display: flex;
    align-items: center;
    gap: 2px;
    opacity: 0.7;
  }

  .bubble.sender .message-status {
    color: #64748b;
  }

  .bubble.receiver .message-status {
    color: #64748b;
  }

  /* Media content in messages */
  .bubble img,
  .bubble video {
    max-width: 100%;
    max-height: 300px;
    border-radius: 8px;
    margin-top: 4px;
  }

  .bubble a {
    color: inherit;
    text-decoration: underline;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .bubble.sender a {
    color: #e0e7ff;
  }

  /* Input area - fixed at bottom */
  .chat-input {
    border-top: 1px solid #e2e8f0;
    padding: 1rem 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    flex-shrink: 0;
    background: transparent;
    position: relative;
    border-radius: 0 0 12px 12px;
  }

  .chat-input-preview {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0.5rem;
    background: var(--cf-sidebar-bg);
    border-radius: 8px;
    border: 1px solid #e2e8f0;
  }

  .chat-input-preview img,
  .chat-input-preview video {
    max-width: 60px;
    max-height: 60px;
    border-radius: 6px;
    object-fit: cover;
  }

  .chat-input-preview .preview-cancel {
    cursor: pointer;
    color: #dc2626;
    font-size: 1.2rem;
    margin-left: auto;
    padding: 2px;
    border-radius: 4px;
    transition: background-color 0.15s;
  }

  .chat-input-preview .preview-cancel:hover {
    background: rgba(220, 38, 38, 0.1);
  }

  .input-group-chat {
    display: flex;
    gap: 0.5rem;
    align-items: flex-end;
  }

  .chat-input #chatInput {
    flex: 1;
    border: 1px solid #e2e8f0;
    border-radius: 24px;
    padding: 0.75rem 1rem;
    resize: none;
    max-height: 120px;
    transition: border-color 0.15s, box-shadow 0.15s;
  }

  .chat-input #chatInput:focus {
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
  }

  .chat-input button {
    border-radius: 50%;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.15s ease;
  }

  .chat-input button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  #chatSend {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    border: none;
  }

  #chatAttach {
    border: 1px solid #e2e8f0;
    background: var(--cf-sidebar-bg);
    color: #6b7280;
  }

  /* Responsive design */
  @media (max-width: 1024px) {
    .chat-container {
      grid-template-columns: 280px 1fr;
    }
    
    .bubble {
      max-width: 85%;
    }
  }

  @media (max-width: 768px) {
    .chat-container {
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
      gap: 0;
      padding: 0.5rem;
    }
    
    .chat-sidebar {
      border-radius: 12px 12px 0 0;
      max-height: 200px;
    }
    
    .chat-main {
      border-radius: 0 0 12px 12px;
    }
    
    .bubble {
      max-width: 90%;
    }
    
    .chat-input {
      padding: 0.75rem 1rem;
    }
  }

  @media (max-width: 480px) {
    .content-container {
      height: calc(100vh - 80px);
    }
    
    .chat-container {
      padding: 0.25rem;
    }
    
    .bubble {
      max-width: 95%;
      padding: 0.6rem 0.8rem;
    }
    
    .chat-input button {
      width: 40px;
      height: 40px;
    }
  }

  /* Loading states and animations */
  .bubble {
    animation: fadeInUp 0.3s ease-out;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Empty state */
  .empty-chat {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #9ca3af;
    text-align: center;
    padding: 2rem;
  }

  .empty-chat i {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
  }
</style>
{% endblock %}

{% block content %}
<div class="content-container">
  <!-- Hidden input for total unread count -->
  <input type="hidden" id="totalUnreadCount" value="{{ total_unread_count|default:0 }}">
  
  <div class="chat-container">
    <div class="chat-sidebar">
      <div class="d-flex align-items-center gap-2 mb-3">
        <div class="position-relative flex-grow-1">
          <input type="text" id="chatSearch" class="form-control search-input-chat" placeholder="Search users...">
          <button id="chatSearchBtn" class="btn btn-outline-secondary position-absolute end-0 top-0 h-100" style="border-left: none;">
            <i class="bi bi-search"></i>
          </button>
        </div>
      </div>
      <div id="searchResults" class="recents mt-2" style="display:none;"></div>
      <div class="mt-2 small text-muted fw-semibold">Recent Conversations</div>
      <div id="recentList" class="recents">
        
        {% for u in recents %}
        <div class="recent-item" data-user-id="{{ u.id }}">
          {% if u|get_profile_image %}
            <img src="data:image/jpeg;base64,{{ u|get_profile_image|b64encode_blob }}" class="avatar">
          {% else %}<i class="bi bi-person-circle fs-4 avatar"></i>{% endif %}
          <div class="flex-grow-1">
            <div class="fw-semibold">
              {{ u.get_full_name|default:u.email }}
              {% if u.message_privacy == 'private' %}
                <i class="bi bi-shield-lock privacy-shield" title="Private messages"></i>
              {% endif %}
            </div>
            <div class="small text-muted">{{ u.role|title }}</div>
            <!-- Simplified last message preview -->
            {% for user_id, last_msg in last_messages.items %}
              {% if user_id == u.id and last_msg and last_msg.content %}
                <div class="last-message-preview">
                  {% if last_msg.sender == request.user %}
                    <i class="bi bi-check2"></i> 
                  {% endif %}
                  {{ last_msg.content|truncatechars:50 }}
                </div>
              {% endif %}
            {% endfor %}
          </div>
          <!-- Simplified unread counter -->
          {% for user_id, count in unread_counts.items %}
            {% if user_id == u.id and count > 0 %}
              <span class="unread-badge">{{ count }}</span>
            {% endif %}
          {% endfor %}
          {% if unread_counts|get_item:u.id == 0 or not unread_counts|get_item:u.id %}
            <span class="unread-badge" style="display:none;">0</span>
          {% endif %}
          <!-- Simplified last message time -->
          {% for user_id, time in last_message_times.items %}
            {% if user_id == u.id %}
              <div class="last-message-time">{{ time|timesince }}</div>
            {% endif %}
          {% endfor %}
        </div>
        {% empty %}
        <div class="text-muted text-center py-4">
          <i class="bi bi-chat-dots fs-1 opacity-25"></i>
          <div class="mt-2">No recent chats</div>
        </div>
        {% endfor %}
      </div>
    </div>

    <div class="chat-main">
      <div class="chat-header" id="chatHeader">
        <div class="empty-chat">
          <i class="bi bi-chat-square-text"></i>
          <h5>Select a conversation</h5>
          <p class="mb-0">Choose from your existing conversations or search for someone to start a new chat.</p>
        </div>
      </div>
      <div id="chatMessages" class="chat-messages"></div>
      <div class="chat-input">
        <div id="chatInputPreview" class="chat-input-preview" style="display:none;"></div>
        <div class="input-group-chat">
          <input id="chatInput" type="text" class="form-control" placeholder="Type a message..." autocomplete="on">
        <input id="chatFile" type="file" style="display:none;" multiple>
        <button id="chatAttach" class="btn btn-outline-secondary" title="Attach file"><i class="bi bi-paperclip"></i></button>
        <button id="chatSend" class="btn btn-primary"><i class="bi bi-send"></i></button>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
(function(){
  const searchInput = document.getElementById('chatSearch');
  const searchBtn = document.getElementById('chatSearchBtn');
  const results = document.getElementById('searchResults');
  const recents = document.getElementById('recentList');
  const messagesEl = document.getElementById('chatMessages');
  const sendBtn = document.getElementById('chatSend');
  const inputEl = document.getElementById('chatInput');
  const attachBtn = document.getElementById('chatAttach');
  const fileInput = document.getElementById('chatFile');
  const chatHeader = document.getElementById('chatHeader');
  const chatInputPreview = document.getElementById('chatInputPreview');
  let currentPeerId = null;
  let currentPeerData = null;
  let socket = null;
  let unreadIds = [];
  let previewFile = null;
  let previewType = null;
  let previewUrl = null;
  let unreadCounts = {}; // Track unread counts per user
  let lastMessageTimes = {}; // Track last message times
  let recentUsers = Array.from(recents.querySelectorAll('.recent-item')).map(item => ({
    id: item.dataset.userId,
    name: item.querySelector('.fw-semibold').textContent.trim().toLowerCase(),
    el: item
  }));
  const currentUserId = document.querySelector('meta[name="current-user-id"]')?.content || window.currentUserId;
  window.currentUserId = currentUserId;
  let socketListeners = [];
  
  // Get total unread count for navbar updates
  const totalUnreadCount = parseInt(document.getElementById('totalUnreadCount').value) || 0;
  
  // Initialize unread counts from template data
  {% if unread_counts %}
    {% for user_id, count in unread_counts.items %}
      unreadCounts['{{ user_id }}'] = {{ count }};
    {% endfor %}
  {% endif %}
  
  // Initialize last message times from template data
  {% if last_message_times %}
    {% for user_id, time in last_message_times.items %}
      lastMessageTimes['{{ user_id }}'] = '{{ time|date:"c" }}';
    {% endfor %}
  {% endif %}
  
  // --- Navbar message counter management ---
  function updateNavbarMessageCounter(count) {
    const messageCounter = document.getElementById('messageCounter');
    if (messageCounter) {
      if (count > 0) {
        messageCounter.textContent = count > 99 ? '99+' : count;
        messageCounter.style.display = 'inline';
      } else {
        messageCounter.style.display = 'none';
      }
    }
  }
  
  // Initialize navbar counter
  updateNavbarMessageCounter(totalUnreadCount);
  
  // --- Refresh navbar counter ---
  function refreshNavbarCounter() {
    const totalUnread = Object.values(unreadCounts).reduce((sum, count) => sum + (count || 0), 0);
    updateNavbarMessageCounter(totalUnread);
  }
  
  // Refresh navbar counter every 30 seconds to stay in sync
  setInterval(refreshNavbarCounter, 30000);

  // --- Enhanced search functionality ---
  function renderSearch(results) {
    const searchResultsHtml = results.map(user => `
      <div class="recent-item" data-user-id="${user.id}">
        ${user.avatar ? `<a href="${user.profile_url}" target="_blank"><img src="${user.avatar}" class="avatar"></a>` : `<a href="${user.profile_url}" target="_blank"><i class="bi bi-person-circle fs-4 avatar"></i></a>`}
        <div class="flex-grow-1">
          <div class="fw-semibold">
            <a href="${user.profile_url}" target="_blank" style="text-decoration:none;color:inherit;">
              ${user.name}
              ${user.is_private ? '<i class="bi bi-shield-lock text-muted ms-2" title="Private messages"></i>' : ''}
            </a>
          </div>
          <div class="small text-muted">${user.role || 'User'}</div>
        </div>
      </div>
    `).join('');
    
    document.getElementById('searchResults').innerHTML = searchResultsHtml;
    document.getElementById('searchResults').style.display = results.length ? 'block' : 'none';
  }

  // --- Sidebar: Unread badge logic ---
  function setUnreadBadge(userId, count) {
    const item = recents.querySelector(`.recent-item[data-user-id="${userId}"]`);
    if (item) {
      const badge = item.querySelector('.unread-badge');
      const oldCount = unreadCounts[userId] || 0;
      unreadCounts[userId] = count;
      
      if (count > 0) {
        badge.textContent = count > 99 ? '99+' : count;
        badge.style.display = 'block';
        item.classList.add('has-unread');
      } else {
        badge.style.display = 'none';
        item.classList.remove('has-unread');
      }
      
      // Update navbar counter
      refreshNavbarCounter();
    }
  }

  // --- Update unread count when receiving messages ---
  function updateUnreadCount(senderId, increment = true) {
    if (senderId == currentPeerId) {
      setUnreadBadge(senderId, 0);
    } else {
      const currentCount = unreadCounts[senderId] || 0;
      setUnreadBadge(senderId, increment ? currentCount + 1 : currentCount);
    }
  }

  // --- Sort recent chats by last message time ---
  function sortRecentChats() {
    const items = Array.from(recents.querySelectorAll('.recent-item'));
    items.sort((a, b) => {
      const timeA = lastMessageTimes[a.dataset.userId] ? new Date(lastMessageTimes[a.dataset.userId]) : new Date(0);
      const timeB = lastMessageTimes[b.dataset.userId] ? new Date(lastMessageTimes[b.dataset.userId]) : new Date(0);
      return timeB - timeA; // Most recent first
    });
    
    // Re-append in sorted order
    items.forEach(item => recents.appendChild(item));
  }

  // --- Format time for display ---
  function formatMessageTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    
    // Check if it's today
    if (date.toDateString() === now.toDateString()) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    
    // Check if it's this week
    const diffTime = now - date;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays < 7) {
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      return days[date.getDay()];
    }
    
    // Older than a week
    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
  }

  // --- Sidebar: Contact selection ---
  function selectContact(userId) {
    Array.from(recents.querySelectorAll('.recent-item')).forEach(item => {
      item.classList.toggle('selected', item.dataset.userId == userId);
    });
  }

  // --- Sidebar: Dynamic search ---
  searchInput.addEventListener('input', function() {
    const q = this.value.trim().toLowerCase();
    recentUsers.forEach(u => {
      u.el.style.display = (!q || u.name.includes(q)) ? 'block' : 'none';
    });
    if (q.length > 0) {
      // Determine the correct search endpoint based on current user's role
      const currentUserRole = '{{ user.role }}' || 'investor';
      const searchEndpoint = currentUserRole === 'investor' ? '/investor/messages/search/' : '/entrepreneur/messages/search/';
      
      fetch(`${searchEndpoint}?q=${encodeURIComponent(q)}`)
        .then(r=>r.json())
        .then(d=> renderSearch(d.results || []))
        .catch(() => renderSearch([]));
    } else {
      results.style.display = 'none';
    }
  });

  // --- Sidebar: Click to open chat ---
  recents.addEventListener('click', e => {
    const item = e.target.closest('.recent-item');
    if (!item) return;
    const userId = item.dataset.userId;
    const role = item.querySelector('.small.text-muted').textContent.toLowerCase();
    const profileUrl = role === 'investor' ? `/investor/profile/${userId}/` : `/entrepreneur/profile/${userId}/`;
    
    // Check if user has private messages by looking for the lock icon
    const isPrivate = item.querySelector('.bi-shield-lock') !== null;
    
    openChat(userId, {
      name: item.querySelector('.fw-semibold').textContent.replace('🔒', '').trim(),
      avatar: item.querySelector('img') ? item.querySelector('img').src : null,
      role: item.querySelector('.small.text-muted').textContent,
      profile_url: profileUrl,
      is_private: isPrivate
    });
    selectContact(userId);
  });

  // --- Search results: Click to open chat ---
  results.addEventListener('click', e => {
    const item = e.target.closest('.recent-item');
    if (!item) return;
    const userId = item.dataset.userId;
    const role = item.querySelector('.small.text-muted').textContent.toLowerCase();
    const profileUrl = role === 'investor' ? `/investor/profile/${userId}/` : `/entrepreneur/profile/${userId}/`;
    
    // Check if user has private messages from search results
    const isPrivate = item.querySelector('.bi-shield-lock') !== null;
    
    openChat(userId, {
      name: item.querySelector('.fw-semibold').textContent.replace('🔒', '').trim(),
      avatar: item.querySelector('img') ? item.querySelector('img').src : null,
      role: item.querySelector('.small.text-muted').textContent,
      profile_url: profileUrl,
      is_private: isPrivate
    });
    selectContact(userId);
    results.style.display = 'none';
    searchInput.value = '';
  });

  // --- Chat open logic ---
  function cleanupSocket() {
    if (socket) {
      socket.onopen = null;
      socket.onmessage = null;
      socket.onclose = null;
      socket.onerror = null;
      if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {
        socket.close();
      }
      socket = null;
    }
    socketListeners.forEach(fn => fn && fn());
    socketListeners = [];
  }

  function openChat(peerId, peerData) {
    if (currentPeerId === peerId) return;
    
    // Clean up previous connection
    cleanupSocket();
    
    currentPeerId = peerId;
    currentPeerData = peerData;
    unreadIds = [];
    
    // Clear previous messages
    messagesEl.innerHTML = '';
    
    // Update chat header with proper styling
    chatHeader.innerHTML = `
      <div class="chat-header-avatar">
        ${peerData.avatar ? `<a href="${peerData.profile_url || '#'}" target="_blank"><img src="${peerData.avatar}" alt="${peerData.name}" style="width:40px;height:40px;border-radius:50%;object-fit:cover;"></a>` : `<a href="${peerData.profile_url || '#'}" target="_blank"><div class="avatar-placeholder"><i class="bi bi-person-circle"></i></div></a>`}
      </div>
      <div class="flex-grow-1">
        <div class="fw-semibold text-dark">
          <a href="${peerData.profile_url || '#'}" target="_blank" style="text-decoration:none;color:inherit;">${peerData.name}</a>
          ${peerData.is_private ? '<i class="bi bi-shield-lock text-muted ms-2" title="Private messages"></i>' : ''}
        </div>
        <small class="text-muted">${peerData.role}</small>
      </div>
    `;
    
    // Highlight selected contact
    selectContact(peerId);
    
    // Connect WebSocket with error handling
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    try {
    socket = new WebSocket(`${wsScheme}://${window.location.host}/ws/chat/${peerId}/`);
    
    socket.onopen = function() {
        console.log('WebSocket connection established');
    };
    
    socket.onmessage = function(e){
        try {
      const data = JSON.parse(e.data);
      if (data.type === 'chat_message') {
        const existingMessage = messagesEl.querySelector(`[data-message-id="${data.message.id}"]`);
        if (!existingMessage) {
          renderMessage(data.message);
              if (String(data.message.sender) !== String(currentUserId)) {
                if (String(data.message.sender) === String(peerId)) {
                  setUnreadBadge(peerId, 0);
            } else {
                  updateUnreadCount(data.message.sender);
            }
          }
        }
      } else if (data.type === 'read_receipt') {
        updateReadReceipts(data.message_ids, data.reader_id);
      } else if (data.type === 'error') {
        // Handle server-side errors
        if (data.error && data.error.includes('privacy')) {
          showPrivacyError('Message blocked due to privacy settings.');
        } else {
          showPrivacyError('Error sending message: ' + (data.error || 'Unknown error'));
        }
      }
        } catch (err) {
          console.error('Error processing WebSocket message:', err);
        }
      };
      
      socket.onerror = function(error) {
        console.error('WebSocket error:', error);
      };
      
      socket.onclose = function(e) {
        console.log('WebSocket connection closed:', e.code, e.reason);
        
        // Handle privacy violations
        if (e.code === 4001) {
          showPrivacyError('Cannot connect to this user due to privacy settings. You need to be connected to send messages.');
          // Reset chat state
          currentPeerId = null;
          currentPeerData = null;
          showEmptyState();
        }
        
        socket = null;
      };
      
    } catch (error) {
      console.error('Error creating WebSocket:', error);
    }
    
    // Fetch existing messages
    const currentUserRole = '{{ user.role }}' || 'investor';
    const endpoint = currentUserRole === 'investor' ? `/investor/messages/${peerId}/` : `/entrepreneur/messages/${peerId}/`;
    fetch(endpoint, {
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        }
    })
      .then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return r.json();
      })
      .then(d => {
        (d.messages||[]).forEach(m => {
          renderMessage(m);
          if (!m.is_read && String(m.sender) !== String(currentUserId)) {
            unreadIds.push(m.id);
          }
        });
        
        // Mark messages as read
        if (unreadIds.length && socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({action:'mark_read', message_ids: unreadIds}));
        }
        
        setUnreadBadge(peerId, 0);
        
        // Restore unread counts for other conversations
        Object.keys(unreadCounts).forEach(userId => {
          if (userId != peerId && unreadCounts[userId] > 0) {
            setUnreadBadge(userId, unreadCounts[userId]);
          }
        });
        
        // Scroll to bottom with slight delay
        setTimeout(() => { 
          messagesEl.scrollTop = messagesEl.scrollHeight; 
        }, 100);
      })
      .catch(error => {
        console.error('Error fetching messages:', error);
        if (error.message && error.message.includes('403')) {
          messagesEl.innerHTML = '<div class="text-center text-muted py-4"><i class="bi bi-shield-lock fs-1 opacity-25"></i><div class="mt-2">This user has set their messages to private. You cannot send messages to them at this time. Any previous messages in this chat will remain hidden until the user allows messages again.</div>';
        } else {
          messagesEl.innerHTML = '<div class="text-center text-muted py-4"><i class="bi bi-exclamation-triangle fs-1 opacity-25"></i><div class="mt-2">Unable to load messages</div><div class="small">Please try again later.</div></div>';
        }
      });
    
    clearPreview();
  }

  // --- Media preview logic ---
  function showPreview(file) {
    previewFile = file;
    previewType = null;
    previewUrl = null;
    chatInputPreview.innerHTML = '';
    
    if (!file) { 
      chatInputPreview.style.display = 'none'; 
      return; 
    }
    
    let type = 'document';
    if (file.type.startsWith('image/')) type = 'image';
    else if (file.type.startsWith('video/')) type = 'video';
    
    previewType = type;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      previewUrl = e.target.result;
      let html = '';
      
      if (type === 'image') {
        html = `<img src="${previewUrl}" alt="Preview">`;
      } else if (type === 'video') {
        html = `<video src="${previewUrl}" controls></video>`;
      } else {
        html = `<div class="d-flex align-items-center"><i class="bi bi-file-earmark me-2"></i> ${file.name}</div>`;
      }
      
      html += `<span class="preview-cancel" title="Remove">&times;</span>`;
      chatInputPreview.innerHTML = html;
      chatInputPreview.style.display = 'flex';
      
      const cancelBtn = chatInputPreview.querySelector('.preview-cancel');
      if (cancelBtn) {
        cancelBtn.onclick = clearPreview;
      }
    };
    
    reader.readAsDataURL(file);
  }
  
  function clearPreview() {
    previewFile = null; 
    previewType = null; 
    previewUrl = null;
    chatInputPreview.innerHTML = '';
    chatInputPreview.style.display = 'none';
    fileInput.value = '';
  }
  
  fileInput.addEventListener('change', function(){
    if (fileInput.files.length) {
      showPreview(fileInput.files[0]);
    } else {
      clearPreview();
    }
  });

  // --- Chat message rendering with proper alignment ---
  function renderMessage(m) {
    // Prevent duplicate messages
    if (m.id && messagesEl.querySelector(`[data-message-id="${m.id}"]`)) return;
    
    const bubble = document.createElement('div');
    const isMe = String(m.sender) === String(currentUserId);
    
    // Proper class assignment for alignment
    bubble.className = 'bubble ' + (isMe ? 'sender' : 'receiver');
    
    if (m.id) {
      bubble.setAttribute('data-message-id', m.id);
    }
    
    // Handle different message types
    if (m.message_type === 'image' && m.file_base64) {
      bubble.innerHTML = `<img src="data:${m.file_type || 'image/jpeg'};base64,${m.file_base64}" alt="Image" style="max-width:250px;max-height:250px;display:block;border-radius:8px;">`;
    } else if (m.message_type === 'video' && m.file_base64) {
      bubble.innerHTML = `<video controls style="max-width:250px;max-height:200px;border-radius:8px;"><source src="data:${m.file_type || 'video/mp4'};base64,${m.file_base64}"></video>`;
    } else if (m.message_type === 'document' && m.file_name) {
      bubble.innerHTML = `<a href="data:${m.file_type};base64,${m.file_base64}" download="${m.file_name}"><i class="bi bi-file-earmark"></i> ${m.file_name}</a>`;
    } else {
      bubble.textContent = m.content || '';
    }
    
    // Add status indicator for sent messages
    if (isMe) {
      const statusDiv = document.createElement('div');
      statusDiv.className = 'message-status';
      if (m.is_read) {
        statusDiv.innerHTML = '<i class="bi bi-check2-all text-primary"></i>';
      } else {
        statusDiv.innerHTML = '<i class="bi bi-check"></i>';
      }
      bubble.appendChild(statusDiv);
    }
    
    messagesEl.appendChild(bubble);
    
    // Auto-scroll to bottom with smooth behavior
    requestAnimationFrame(() => {
    messagesEl.scrollTop = messagesEl.scrollHeight;
    });
  }

  function updateReadReceipts(ids, readerId) {
    if (String(readerId) === String(currentUserId)) return;
    
    // Update all my sent messages to show as read
    const myMessages = messagesEl.querySelectorAll('.bubble.sender');
    myMessages.forEach(bubble => {
      const statusDiv = bubble.querySelector('.message-status');
      if (statusDiv) {
        statusDiv.innerHTML = '<i class="bi bi-check2-all text-primary"></i>';
      }
    });
  }

    // --- Send message functionality ---
  function sendMessage() {
    if (!currentPeerId || !socket || socket.readyState !== WebSocket.OPEN) {
      console.warn('Cannot send message: no connection');
      return;
    }
    
    // Frontend privacy validation
    if (currentPeerData && currentPeerData.is_private) {
      // Check if we have a connection with this user
      const hasConnection = checkUserConnection(currentPeerId);
      if (!hasConnection) {
        showPrivacyError('This user has private messages. You need to be connected to send messages.');
        return;
      }
    }
    
    const text = inputEl.value.trim();
    
    if (previewFile) {
      const file = previewFile;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
        const base64 = e.target.result.split(',')[1];
        const messageData = {
          action: 'send_message',
            content: text || '',
          message_type: previewType,
          file_data: base64,
          file_name: file.name,
          file_type: file.type,
          file_size: file.size
        };
        socket.send(JSON.stringify(messageData));
        clearPreview();
        inputEl.value = '';
        
        // Update recent chats list to include this user if not already present
        updateRecentChatsList(currentPeerId, currentPeerData);
      } catch (error) {
          console.error('Error sending file:', error);
        }
      };
      reader.readAsDataURL(file);
    } else if (text) {
      try {
        socket.send(JSON.stringify({ 
          action: 'send_message', 
          content: text, 
          message_type: 'text' 
        }));
        inputEl.value = '';
        
        // Update recent chats list to include this user if not already present
        updateRecentChatsList(currentPeerId, currentPeerData);
      } catch (error) {
        console.error('Error sending message:', error);
      }
    }
  }

  // --- Privacy validation helpers ---
  function checkUserConnection(userId) {
    // Check if current user follows the target user or vice versa
    // This is a simplified check - in a real app, you'd want to fetch this from the server
    const followingItem = recents.querySelector(`[data-user-id="${userId}"]`);
    return followingItem !== null; // If they're in recent chats, there's likely a connection
  }
  
  function showPrivacyError(message) {
    // Show privacy error message
    const errorDiv = document.createElement('div');
    errorDiv.className = 'alert alert-warning alert-dismissible fade show';
    errorDiv.innerHTML = `
      <i class="bi bi-shield-lock me-2"></i>
      ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    // Insert at the top of chat messages
    messagesEl.insertBefore(errorDiv, messagesEl.firstChild);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (errorDiv.parentNode) {
        errorDiv.remove();
      }
    }, 5000);
  }
  
  // --- Update recent chats list without page reload ---
  function updateRecentChatsList(userId, userData) {
    // Check if user is already in recent list
    const existingItem = recents.querySelector(`[data-user-id="${userId}"]`);
    if (!existingItem) {
      // Create new recent item
      const newItem = document.createElement('div');
      newItem.className = 'recent-item';
      newItem.setAttribute('data-user-id', userId);
      
      const role = userData.role.toLowerCase();
      const profileUrl = role === 'investor' ? `/investor/profile/${userId}/` : `/entrepreneur/profile/${userId}/`;
      
      newItem.innerHTML = `
        ${userData.avatar ? `<a href="${profileUrl}" target="_blank"><img src="${userData.avatar}" class="avatar"></a>` : `<a href="${profileUrl}" target="_blank"><i class="bi bi-person-circle fs-4 avatar"></i></a>`}
        <div class="flex-grow-1">
          <div class="fw-semibold"><a href="${profileUrl}" target="_blank" style="text-decoration:none;color:inherit;">${userData.name}</a></div>
          <div class="small text-muted">${userData.role}</div>
        </div>
        <span class="unread-badge" style="display:none;">0</span>
      `;
      
      // Add click event listener to the new item
      newItem.addEventListener('click', function() {
        openChat(userId, {
          name: userData.name,
          avatar: userData.avatar,
          role: userData.role,
          profile_url: profileUrl,
          is_private: userData.is_private || false
        });
        selectContact(userId);
      });
      
      // Add to the beginning of the list
      recents.insertBefore(newItem, recents.firstChild);
      
      // Update the recentUsers array
      recentUsers.unshift({
        id: userId,
        name: userData.name.toLowerCase(),
        el: newItem
      });
    }
  }

  // --- Event listeners ---
  // Send message event listeners
  sendBtn.addEventListener('click', sendMessage);
  inputEl.addEventListener('keypress', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });
  
  attachBtn.addEventListener('click', () => fileInput.click());

  // --- Cleanup on page unload ---
  window.addEventListener('beforeunload', cleanupSocket);
  
  // --- Initialize empty state ---
  function showEmptyState() {
    chatHeader.innerHTML = `
      <div class="empty-chat">
        <i class="bi bi-chat-square-text"></i>
        <h5>Select a conversation</h5>
        <p class="mb-0">Choose from your existing conversations or search for someone to start a new chat.</p>
      </div>
    `;
    messagesEl.innerHTML = '';
  }
  
  // Check if we should open a specific chat from URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const openChatId = urlParams.get('open_chat');
  
  if (openChatId) {
    // Find the user in recent chats or search for them
    const recentItem = recents.querySelector(`[data-user-id="${openChatId}"]`);
    if (recentItem) {
      // User is in recent chats, open their chat
      const userId = openChatId;
      const role = recentItem.querySelector('.small.text-muted').textContent.toLowerCase();
      const profileUrl = role === 'investor' ? `/investor/profile/${userId}/` : `/entrepreneur/profile/${userId}/`;
      const isPrivate = recentItem.querySelector('.bi-shield-lock') !== null;
      
      openChat(userId, {
        name: recentItem.querySelector('.fw-semibold').textContent.replace('🔒', '').trim(),
        avatar: recentItem.querySelector('img') ? recentItem.querySelector('img').src : null,
        role: recentItem.querySelector('.small.text-muted').textContent,
        profile_url: profileUrl,
        is_private: isPrivate
      });
      selectContact(userId);
      
      // Clear the URL parameter
      window.history.replaceState({}, document.title, window.location.pathname);
    } else {
      // User not in recent chats, search for them
      const currentUserRole = '{{ user.role }}' || 'investor';
      const searchEndpoint = currentUserRole === 'investor' ? `/investor/messages/search/` : `/entrepreneur/messages/search/`;
      fetch(`${searchEndpoint}?q=${openChatId}`)
        .then(r => r.json())
        .then(d => {
          const user = d.results.find(u => u.id == openChatId);
          if (user) {
            openChat(user.id, {
              name: user.name,
              avatar: user.avatar,
              role: user.role,
              profile_url: user.profile_url,
              is_private: user.is_private
            });
            selectContact(user.id);
            
            // Clear the URL parameter
            window.history.replaceState({}, document.title, window.location.pathname);
          } else {
            showEmptyState();
          }
        })
        .catch(() => {
          showEmptyState();
        });
    }
  } else if (!currentPeerId) {
    // Show empty state initially if no chat is selected
    showEmptyState();
  }
  
  // --- Enhanced responsive behavior ---
  function handleResize() {
    if (messagesEl.scrollHeight > messagesEl.clientHeight) {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
  }
  
  window.addEventListener('resize', handleResize);
  
  // --- Auto-focus input when chat is opened ---
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.target === chatHeader && currentPeerId) {
        setTimeout(() => inputEl.focus(), 100);
      }
    });
  });
  
  observer.observe(chatHeader, { childList: true });
  
  // Sort recent chats on initial load
  setTimeout(sortRecentChats, 100);
  
  // Initialize the messaging system
  function initializeMessagingSystem() {
    // Initialize unread counts display
    Object.keys(unreadCounts).forEach(userId => {
      const count = unreadCounts[userId];
      if (count > 0) {
        setUnreadBadge(userId, count);
      }
    });
    
    // Initialize navbar counter
    refreshNavbarCounter();
    
    // Sort recent chats by timestamp
    sortRecentChats();
    
    // Set up periodic sync
    setInterval(refreshNavbarCounter, 30000);
    
    // Add has-unread class to items with unread messages
    Object.keys(unreadCounts).forEach(userId => {
      const count = unreadCounts[userId];
      if (count > 0) {
        const item = recents.querySelector(`[data-user-id="${userId}"]`);
        if (item) {
          item.classList.add('has-unread');
        }
      }
    });
  }

  // --- Initialize on page load ---
  document.addEventListener('DOMContentLoaded', function() {
    initializeMessagingSystem();
  });
  
})();
</script>
{% endblock %}