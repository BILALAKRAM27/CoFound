{% extends 'base.html' %}
{% load static %}
{% load profile_filters %}

{% block title %}Messages - CoFound{% endblock %}
{% block extra_head %}
  <meta name="current-user-id" content="{{ request.user.id }}">
{% endblock %}

{% block styles %}
<style>
  /* Main container with proper height calculation */
  .content-container {
    padding: 0;
    margin: 0;
    height: calc(100vh - 120px);
    overflow: hidden;
  }

  .chat-container {
    display: grid;
    grid-template-columns: 320px 1fr;
    height: 100%;
    gap: 1rem;
    padding: 1rem;
    box-sizing: border-box;
  }

  /* Sidebar styling */
  .chat-sidebar {
    background: var(--bs-body-bg);
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    padding: 1rem;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.08);
  }

  .search-input-chat {
    border-radius: 8px;
    border: 1px solid #e2e8f0;
    transition: border-color 0.15s, box-shadow 0.15s;
  }

  .search-input-chat:focus {
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
  }

  .recents {
    flex: 1;
    overflow-y: auto;
    margin-top: 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 transparent;
  }

  .recents::-webkit-scrollbar {
    width: 6px;
  }

  .recents::-webkit-scrollbar-track {
    background: transparent;
  }

  .recents::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
  }

  .recent-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.15s ease;
    position: relative;
    margin-bottom: 0.25rem;
    border: 1px solid transparent;
  }

  .recent-item:hover {
    background: #f8fafc;
    border-color: #e2e8f0;
    transform: translateY(-1px);
  }

  .recent-item.active,
  .recent-item:active,
  .recent-item.selected {
    background: #e0e7ff;
    border-color: #c7d2fe;
  }

  .recent-item .avatar {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    object-fit: cover;
    background: #f3f4f6;
    border: 2px solid #e5e7eb;
    flex-shrink: 0;
  }

  .recent-item .unread-badge {
    background: #dc2626;
    color: #fff;
    font-size: 11px;
    font-weight: 600;
    border-radius: 12px;
    padding: 3px 8px;
    position: absolute;
    right: 12px;
    top: 12px;
    min-width: 20px;
    text-align: center;
    line-height: 1.2;
    box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3);
  }
  
  .recent-item .last-message-preview {
    color: #6b7280;
    font-size: 0.8rem;
    margin-top: 2px;
    line-height: 1.3;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 200px;
  }
  
  .recent-item .last-message-preview .bi-check2 {
    color: #2563eb;
    margin-right: 4px;
  }

  .recent-item .last-message-time {
    position: absolute;
    top: 12px;
    right: 12px;
    font-size: 11px;
    color: #9ca3af;
  }

  .recent-item.has-unread .last-message-time {
    top: 32px;
  }

  /* Privacy shield icon */
  .privacy-shield {
    color: #6b7280;
    margin-left: 4px;
    font-size: 12px;
  }

  /* Main chat area */
  .chat-main {
    background: var(--bs-body-bg);
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.08);
    position: relative;
  }

  .chat-header {
    padding: 1rem 1.25rem;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-shrink: 0;
    background: transparent;
    border-radius: 12px 12px 0 0;
  }

  .chat-header-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    flex-shrink: 0;
  }

  .chat-header-avatar img {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
  }

  .chat-header .avatar-placeholder {
    background: transparent !important;
    color: var(--cf-text-secondary);
  }

  .chat-header .fw-semibold,
  .chat-header .fw-semibold.text-dark {
    color: var(--cf-text-primary) !important;
  }

  /* Messages area with proper scrolling */
  .chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    min-height: 0;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 transparent;
  }

  .chat-messages::-webkit-scrollbar {
    width: 6px;
  }

  .chat-messages::-webkit-scrollbar-track {
    background: transparent;
  }

  .chat-messages::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
  }

  /* Message bubbles with proper alignment and timestamp space */
  .bubble {
    max-width: 75%;
    padding: 0.75rem 1rem 1.5rem 1rem; /* Extra bottom padding for timestamp */
    border-radius: 18px;
    position: relative;
    word-wrap: break-word;
    word-break: break-word;
    line-height: 1.4;
    font-size: 14px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    margin-bottom: 8px; /* More space for timestamp */
  }

  /* Sender (outgoing messages - right side) */
  .bubble.sender {
    align-self: flex-end;
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    color: #ffffff;
    margin-left: auto;
    border-bottom-right-radius: 6px;
  }

  /* Receiver (incoming messages - left side) */
  .bubble.receiver {
    align-self: flex-start;
    background: #c2c9ff;
    color: #1f2937;
    margin-right: auto;
    border: 1px solid #e2e8f0;
    border-bottom-left-radius: 6px;
  }

  /* Enhanced message status indicators - positioned properly */
  .message-status {
    position: absolute;
    bottom: 4px;
    font-size: 10px;
    display: flex;
    align-items: center;
    gap: 3px;
    opacity: 0.8;
    line-height: 1;
  }

  .bubble.sender .message-status {
    right: 8px;
    color: rgba(255, 255, 255, 0.7);
  }

  .bubble.receiver .message-status {
    left: 8px;
    color: #64748b;
  }

  .message-status .msg-time {
    font-size: 10px;
    font-weight: 400;
  }

  .message-status .read-tick {
    font-size: 12px;
  }

  .message-status .read-tick.read {
    color: #2563eb;
  }

  .bubble.sender .message-status .read-tick.read {
    color: #93c5fd;
  }

  /* Media content in messages */
  .bubble img,
  .bubble video {
    max-width: 100%;
    max-height: 300px;
    border-radius: 8px;
    margin-top: 4px;
  }

  .bubble a {
    color: inherit;
    text-decoration: underline;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .bubble.sender a {
    color: #e0e7ff;
  }

  /* Input area - fixed at bottom */
  .chat-input {
    border-top: 1px solid #e2e8f0;
    padding: 1rem 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    flex-shrink: 0;
    background: #fafbfc;
    position: relative;
    border-radius: 0 0 12px 12px;
  }

  /* Privacy message styling */
  .privacy-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    text-align: center;
    background: #fef3cd;
    border: 1px solid #f6d55c;
    border-radius: 8px;
    margin: 1rem;
  }

  .privacy-message i {
    font-size: 2rem;
    color: #d97706;
    margin-bottom: 0.5rem;
  }

  .privacy-message h6 {
    color: #92400e;
    margin-bottom: 0.5rem;
  }

  .privacy-message p {
    color: #a16207;
    margin: 0;
  }

  .chat-input-preview {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0.5rem;
    background: #f1f5f9;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
  }

  .chat-input-preview img,
  .chat-input-preview video {
    max-width: 60px;
    max-height: 60px;
    border-radius: 6px;
    object-fit: cover;
  }

  .chat-input-preview .preview-cancel {
    cursor: pointer;
    color: #dc2626;
    font-size: 1.2rem;
    margin-left: auto;
    padding: 2px;
    border-radius: 4px;
    transition: background-color 0.15s;
  }

  .chat-input-preview .preview-cancel:hover {
    background: rgba(220, 38, 38, 0.1);
  }

  .input-group-chat {
    display: flex;
    gap: 0.5rem;
    align-items: flex-end;
  }

  .chat-input #chatInput {
    flex: 1;
    border: 1px solid #e2e8f0;
    border-radius: 24px;
    padding: 0.75rem 1rem;
    resize: none;
    max-height: 120px;
    transition: border-color 0.15s, box-shadow 0.15s;
  }

  .chat-input #chatInput:focus {
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
  }

  .chat-input button {
    border-radius: 50%;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.15s ease;
  }

  .chat-input button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  #chatSend {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    border: none;
  }

  #chatAttach {
    border: 1px solid #e2e8f0;
    background: #ffffff;
    color: #6b7280;
  }

  /* Responsive design */
  @media (max-width: 1024px) {
    .chat-container {
      grid-template-columns: 280px 1fr;
    }
    
    .bubble {
      max-width: 85%;
    }
  }

  @media (max-width: 768px) {
    .chat-container {
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
      gap: 0;
      padding: 0.5rem;
    }
    
    .chat-sidebar {
      border-radius: 12px 12px 0 0;
      max-height: 200px;
    }
    
    .chat-main {
      border-radius: 0 0 12px 12px;
    }
    
    .bubble {
      max-width: 90%;
    }
    
    .chat-input {
      padding: 0.75rem 1rem;
    }
  }

  @media (max-width: 480px) {
    .content-container {
      height: calc(100vh - 80px);
    }
    
    .chat-container {
      padding: 0.25rem;
    }
    
    .bubble {
      max-width: 95%;
      padding: 0.6rem 0.8rem 1.3rem 0.8rem;
    }
    
    .chat-input button {
      width: 40px;
      height: 40px;
    }
  }

  /* Loading states and animations */
  .bubble {
    animation: fadeInUp 0.3s ease-out;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Empty state */
  .empty-chat {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #9ca3af;
    text-align: center;
    padding: 2rem;
  }

  .empty-chat i {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
  }
</style>
{% endblock %}

{% block content %}
<div class="content-container">
  <!-- Hidden input for total unread count -->
  <input type="hidden" id="totalUnreadCount" value="{{ total_unread_count|default:0 }}">
  
  <div class="chat-container">
    <div class="chat-sidebar">
      <div class="input-group">
        <input id="chatSearch" type="text" class="form-control search-input-chat" placeholder="Search users to message...">
        <button class="btn btn-outline-secondary" id="chatSearchBtn"><i class="bi bi-search"></i></button>
      </div>
      <div id="searchResults" class="recents mt-2" style="display:none;"></div>
      <div class="mt-2 small text-muted fw-semibold">Recent Conversations</div>
      <div id="recentList" class="recents">
        {% for u in recents %}
        <div class="recent-item {% if unread_counts and unread_counts|get_item:u.id > 0 %}has-unread{% endif %}" data-user-id="{{ u.id }}">
          {% if u|get_profile_image %}
            <img src="data:image/jpeg;base64,{{ u|get_profile_image|b64encode_blob }}" class="avatar">
          {% else %}<i class="bi bi-person-circle fs-4 avatar"></i>{% endif %}
          <div class="flex-grow-1">
            <div class="fw-semibold">
              {{ u.get_full_name|default:u.email }}
              {% if u.message_privacy == 'private' %}
                <i class="bi bi-shield-lock privacy-shield" title="Private messages"></i>
              {% endif %}
            </div>
            <div class="small text-muted">{{ u.role|title }}</div>
            {% if last_messages and last_messages|get_item:u.id %}
              <div class="last-message-preview">
                {% if last_messages|get_item:u.id.sender == request.user %}
                  <i class="bi bi-check2"></i> 
                {% endif %}
                {{ last_messages|get_item:u.id.content|truncatechars:50 }}
              </div>
            {% endif %}
          </div>
          {% if unread_counts and unread_counts|get_item:u.id > 0 %}
            <span class="unread-badge">{{ unread_counts|get_item:u.id }}</span>
          {% else %}
            <span class="unread-badge" style="display:none;">0</span>
          {% endif %}
          {% if last_message_times and last_message_times|get_item:u.id %}
            <div class="last-message-time">{{ last_message_times|get_item:u.id|timesince }}</div>
          {% endif %}
        </div>
        {% empty %}
        <div class="text-muted text-center py-4">
          <i class="bi bi-chat-dots fs-1 opacity-25"></i>
          <div class="mt-2">No recent chats</div>
        </div>
        {% endfor %}
      </div>
    </div>

    <div class="chat-main">
      <div class="chat-header" id="chatHeader">
        <div class="empty-chat">
          <i class="bi bi-chat-square-text"></i>
          <h5>Select a conversation</h5>
          <p class="mb-0">Choose from your existing conversations or search for someone to start a new chat.</p>
        </div>
      </div>
      <div id="chatMessages" class="chat-messages"></div>
      <div class="chat-input" id="chatInputArea">
        <div id="chatInputPreview" class="chat-input-preview" style="display:none;"></div>
        <div class="input-group-chat">
          <input id="chatInput" type="text" class="form-control" placeholder="Type a message..." autocomplete="on">
          <input id="chatFile" type="file" style="display:none;" multiple>
          <button id="chatAttach" class="btn btn-outline-secondary" title="Attach file"><i class="bi bi-paperclip"></i></button>
          <button id="chatSend" class="btn btn-primary"><i class="bi bi-send"></i></button>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
(function(){
  const searchInput = document.getElementById('chatSearch');
  const searchBtn = document.getElementById('chatSearchBtn');
  const results = document.getElementById('searchResults');
  const recents = document.getElementById('recentList');
  const messagesEl = document.getElementById('chatMessages');
  const sendBtn = document.getElementById('chatSend');
  const inputEl = document.getElementById('chatInput');
  const attachBtn = document.getElementById('chatAttach');
  const fileInput = document.getElementById('chatFile');
  const chatHeader = document.getElementById('chatHeader');
  const chatInputPreview = document.getElementById('chatInputPreview');
  const chatInputArea = document.getElementById('chatInputArea');
  let currentPeerId = null;
  let currentPeerData = null;
  let socket = null;
  let unreadIds = [];
  let previewFile = null;
  let previewType = null;
  let previewUrl = null;
  let unreadCounts = {}; // Track unread counts per user
  let lastMessageTimes = {}; // Track last message times
  let recentUsers = Array.from(recents.querySelectorAll('.recent-item')).map(item => ({
    id: item.dataset.userId,
    name: item.querySelector('.fw-semibold').textContent.trim().toLowerCase(),
    el: item
  }));
  
  // Always get currentUserId from meta tag and ensure it's a string
  const currentUserId = String(document.querySelector('meta[name="current-user-id"]').content);
  window.currentUserId = currentUserId;
  let socketListeners = [];
  
  // Get total unread count for navbar updates
  const totalUnreadCount = parseInt(document.getElementById('totalUnreadCount').value) || 0;
  
  // Initialize unread counts from template data
  {% if unread_counts %}
    {% for user_id, count in unread_counts.items %}
      unreadCounts['{{ user_id }}'] = {{ count }};
    {% endfor %}
  {% endif %}
  
  // Initialize last message times from template data
  {% if last_message_times %}
    {% for user_id, time in last_message_times.items %}
      lastMessageTimes['{{ user_id }}'] = '{{ time|date:"c" }}';
    {% endfor %}
  {% endif %}
  
  // --- Navbar message counter management ---
  function updateNavbarMessageCounter(count) {
    const messageCounter = document.getElementById('messageCounter');
    if (messageCounter) {
      if (count > 0) {
        messageCounter.textContent = count > 99 ? '99+' : count;
        messageCounter.style.display = 'inline';
      } else {
        messageCounter.style.display = 'none';
      }
    }
  }
  
  // Initialize navbar counter
  updateNavbarMessageCounter(totalUnreadCount);
  
  // --- Refresh navbar counter ---
  function refreshNavbarCounter() {
    const totalUnread = Object.values(unreadCounts).reduce((sum, count) => sum + (count || 0), 0);
    updateNavbarMessageCounter(totalUnread);
  }
  
  // Refresh navbar counter every 30 seconds to stay in sync
  setInterval(refreshNavbarCounter, 30000);
  
  // Also sync with actual DOM state every 10 seconds
  setInterval(syncNavbarCounter, 10000);

  // --- Real-time message updates ---
  function handleNewMessage(message) {
    // Update recent chats list
    if (String(message.sender) !== String(currentUserId)) {
      const senderId = message.sender;
      const senderData = {
        name: message.sender_name || 'User',
        role: 'User',
        lastMessage: message.content || 'Sent a message',
        timestamp: message.timestamp
      };
      updateRecentChatsList(senderId, senderData);
      
      // Update unread count
      if (String(message.sender) === String(currentPeerId)) {
        setUnreadBadge(currentPeerId, 0);
      } else {
        updateUnreadCount(message.sender);
      }
    } else {
      // Message from current user - update recent chat list
      updateRecentChatsList(currentPeerId, {
        name: currentPeerData.name,
        role: currentPeerData.role,
        lastMessage: message.content || 'Sent a message',
        timestamp: message.timestamp
      });
    }
  }

  // --- Enhanced real-time updates with navbar counter sync ---
  function handleMessageUpdate(message, isRead = false) {
    if (String(message.sender) !== String(currentUserId)) {
      // Message from another user
      const senderId = message.sender;
      
      if (isRead && String(senderId) === String(currentPeerId)) {
        // Message was read in current chat
        updateNavbarCounterOnRead(senderId);
      } else if (!isRead) {
        // New unread message
        updateUnreadCount(senderId);
      }
      
      // Update recent chats list
      const senderData = {
        name: message.sender_name || 'User',
        role: 'User',
        lastMessage: message.content || 'Sent a message',
        timestamp: message.timestamp
      };
      updateRecentChatsList(senderId, senderData);
    }
  }

  // --- Enhanced search functionality ---
  function renderSearch(results) {
    const searchResultsHtml = results.map(user => {
      let privacyHtml = '';
      if (user.is_private && !user.can_message) {
        privacyHtml = `<div class="privacy-message mt-2"><i class="bi bi-shield-lock"></i><h6>This user has set messages to private</h6><p>Follow them to send a message.</p></div>`;
      }
      return `
        <div class="recent-item" data-user-id="${user.id}" data-can-message="${user.can_message}" data-is-private="${user.is_private}">
          ${user.avatar ? `<a href="${user.profile_url}" target="_blank"><img src="${user.avatar}" class="avatar"></a>` : `<a href="${user.profile_url}" target="_blank"><i class="bi bi-person-circle fs-4 avatar"></i></a>`}
          <div class="flex-grow-1">
            <div class="fw-semibold">
              <a href="${user.profile_url}" target="_blank" style="text-decoration:none;color:inherit;">
                ${user.name}
                ${user.is_private ? '<i class="bi bi-shield-lock privacy-shield" title="Private messages"></i>' : ''}
              </a>
            </div>
            <div class="small text-muted">${user.role || 'User'}</div>
            ${privacyHtml}
          </div>
        </div>
      `;
    }).join('');
    document.getElementById('searchResults').innerHTML = searchResultsHtml;
    document.getElementById('searchResults').style.display = results.length ? 'block' : 'none';
  }

  // --- Sidebar: Unread badge logic ---
  function setUnreadBadge(userId, count) {
    const item = recents.querySelector(`.recent-item[data-user-id="${userId}"]`);
    if (item) {
      const badge = item.querySelector('.unread-badge');
      const oldCount = unreadCounts[userId] || 0;
      unreadCounts[userId] = count;
      
      if (count > 0) {
        badge.textContent = count > 99 ? '99+' : count;
        badge.style.display = 'block';
        item.classList.add('has-unread');
      } else {
        badge.style.display = 'none';
        item.classList.remove('has-unread');
      }
      
      // Update navbar counter
      refreshNavbarCounter();
    }
  }

  // --- Update unread count when receiving messages ---
  function updateUnreadCount(senderId, increment = true) {
    if (senderId == currentPeerId) {
      setUnreadBadge(senderId, 0);
    } else {
      const currentCount = unreadCounts[senderId] || 0;
      setUnreadBadge(senderId, increment ? currentCount + 1 : currentCount);
    }
  }

  // --- Sidebar: Contact selection ---
  function selectContact(userId) {
    Array.from(recents.querySelectorAll('.recent-item')).forEach(item => {
      item.classList.toggle('selected', item.dataset.userId == userId);
    });
  }

  // --- Sort recent chats by last message time ---
  function sortRecentChats() {
    const items = Array.from(recents.querySelectorAll('.recent-item'));
    items.sort((a, b) => {
      const timeA = lastMessageTimes[a.dataset.userId] ? new Date(lastMessageTimes[a.dataset.userId]) : new Date(0);
      const timeB = lastMessageTimes[b.dataset.userId] ? new Date(lastMessageTimes[b.dataset.userId]) : new Date(0);
      return timeB - timeA; // Most recent first
    });
    
    // Re-append in sorted order
    items.forEach(item => recents.appendChild(item));
  }

  // --- Format time for display ---
  function formatMessageTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    
    // Check if it's today
    if (date.toDateString() === now.toDateString()) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    
    // Check if it's this week
    const diffTime = now - date;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays < 7) {
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      return days[date.getDay()];
    }
    
    // Older than a week
    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
  }

  // --- Check if user can message (privacy check) ---
  function canMessageUser(userData) {
    if (!userData.is_private) return true;
    
    // Check if there's an existing connection/follow relationship
    // This would typically be determined by backend, but we can check if user is in recent chats
    const recentItem = recents.querySelector(`[data-user-id="${userData.id}"]`);
    if (recentItem) {
      // User is in recent chats, which means there's some connection
      return true;
    }
    
    // Check if user is in search results (might be a new connection)
    const searchItem = document.getElementById('searchResults').querySelector(`[data-user-id="${userData.id}"]`);
    if (searchItem) {
      return true;
    }
    
    return false;
  }

  // --- Show privacy restriction UI ---
  function showPrivacyRestriction() {
    chatInputArea.innerHTML = `
      <div class="privacy-message">
        <i class="bi bi-shield-lock"></i>
        <h6>This user's messages are private</h6>
        <p>You need to be connected with this user to send messages.</p>
        <div class="mt-3">
          <button class="btn btn-outline-primary btn-sm" onclick="showNormalInput()">
            <i class="bi bi-person-plus"></i> Try to Connect
          </button>
        </div>
      </div>
    `;
  }

  // --- Restore normal input UI ---
  function showNormalInput() {
    chatInputArea.innerHTML = `
      <div id="chatInputPreview" class="chat-input-preview" style="display:none;"></div>
      <div class="input-group-chat">
        <input id="chatInput" type="text" class="form-control" placeholder="Type a message..." autocomplete="on">
        <input id="chatFile" type="file" style="display:none;" multiple>
        <button id="chatAttach" class="btn btn-outline-secondary" title="Attach file"><i class="bi bi-paperclip"></i></button>
        <button id="chatSend" class="btn btn-primary"><i class="bi bi-send"></i></button>
      </div>
    `;
    
    // Re-establish references
    const newInputEl = document.getElementById('chatInput');
    const newSendBtn = document.getElementById('chatSend');
    const newAttachBtn = document.getElementById('chatAttach');
    const newFileInput = document.getElementById('chatFile');
    const newChatInputPreview = document.getElementById('chatInputPreview');
    
    // Re-establish event listeners
    if (newSendBtn) newSendBtn.addEventListener('click', sendMessage);
    if (newInputEl) {
      newInputEl.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
    }
    if (newAttachBtn) newAttachBtn.addEventListener('click', () => newFileInput.click());
    if (newFileInput) {
      newFileInput.addEventListener('change', function(){
        if (newFileInput.files.length) {
          showPreview(newFileInput.files[0]);
        } else {
          clearPreview();
        }
      });
    }
    // Show the input area and preview
    chatInputArea.style.display = 'flex';
    chatInputPreview.style.display = 'flex';
  }

  // --- Sidebar: Dynamic search ---
  searchInput.addEventListener('input', function() {
    const q = this.value.trim().toLowerCase();
    recentUsers.forEach(u => {
      u.el.style.display = (!q || u.name.includes(q)) ? 'block' : 'none';
    });
    if (q.length > 0) {
      // Determine the correct search endpoint based on current user's role
      const currentUserRole = '{{ user.role }}' || 'investor';
      const searchEndpoint = currentUserRole === 'investor' ? '/investor/messages/search/' : '/entrepreneur/messages/search/';
      
      fetch(`${searchEndpoint}?q=${encodeURIComponent(q)}`)
        .then(r=>r.json())
        .then(d=> renderSearch(d.results || []))
        .catch(() => renderSearch([]));
    } else {
      results.style.display = 'none';
    }
  });

  // --- Sidebar: Click to open chat ---
  recents.addEventListener('click', e => {
    const item = e.target.closest('.recent-item');
    if (!item) return;
    const userId = item.dataset.userId;
    const role = item.querySelector('.small.text-muted').textContent.toLowerCase();
    const profileUrl = role === 'investor' ? `/investor/profile/${userId}/` : `/entrepreneur/profile/${userId}/`;
    
    // Check if user has private messages by looking for the lock icon
    const isPrivate = item.querySelector('.privacy-shield') !== null;
    
    openChat(userId, {
      name: item.querySelector('.fw-semibold').textContent.replace(/\s*🔒/, '').trim(),
      avatar: item.querySelector('img') ? item.querySelector('img').src : null,
      role: item.querySelector('.small.text-muted').textContent,
      profile_url: profileUrl,
      is_private: isPrivate
    });
    selectContact(userId);
  });

  // --- Search results: Click to open chat ---
  results.addEventListener('click', e => {
    const item = e.target.closest('.recent-item');
    if (!item) return;
    const userId = item.dataset.userId;
    const canMessage = item.dataset.canMessage === 'true';
    const isPrivate = item.dataset.isPrivate === 'true';
    const name = item.querySelector('.fw-semibold').textContent.trim();
    const avatar = item.querySelector('img') ? item.querySelector('img').src : null;
    const role = item.querySelector('.small.text-muted').textContent;
    const profileUrl = item.querySelector('a') ? item.querySelector('a').href : '';
    openChat(userId, {
      name,
      avatar,
      role,
      profile_url: profileUrl,
      is_private: isPrivate,
      can_message: canMessage
    });
    selectContact(userId);
    results.style.display = 'none';
    searchInput.value = '';
  });

  // --- Chat open logic ---
  function cleanupSocket() {
    if (socket) {
      socket.onopen = null;
      socket.onmessage = null;
      socket.onclose = null;
      socket.onerror = null;
      if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {
        socket.close();
      }
      socket = null;
    }
    socketListeners.forEach(fn => fn && fn());
    socketListeners = [];
  }

  // --- Update last message preview in recent chats ---
  function updateLastMessagePreview(userId, messageContent, isFromMe = false, timestamp = null) {
    const recentItem = recents.querySelector(`[data-user-id="${userId}"]`);
    if (recentItem) {
      const lastMessagePreview = recentItem.querySelector('.last-message-preview');
      if (lastMessagePreview) {
        const icon = isFromMe ? '<i class="bi bi-check2"></i> ' : '';
        lastMessagePreview.innerHTML = icon + (messageContent || '');
      }
      
      // Update timestamp
      if (timestamp) {
        lastMessageTimes[userId] = timestamp;
        const timeEl = recentItem.querySelector('.last-message-time');
        if (timeEl) {
          timeEl.textContent = formatMessageTime(timestamp);
        } else {
          // Create time element if it doesn't exist
          const timeDiv = document.createElement('div');
          timeDiv.className = 'last-message-time';
          timeDiv.textContent = formatMessageTime(timestamp);
          recentItem.appendChild(timeDiv);
        }
      }
      
      // Move to top of list and re-sort
      setTimeout(sortRecentChats, 100);
    }
  }

  // --- Update navbar counter when messages are marked as read ---
  function updateNavbarCounterOnRead(userId) {
    // Update the unread count for this user
    if (unreadCounts[userId] && unreadCounts[userId] > 0) {
      unreadCounts[userId] = 0;
      setUnreadBadge(userId, 0);
      
      // Update navbar counter
      refreshNavbarCounter();
    }
  }

  function openChat(peerId, peerData) {
    if (currentPeerId === peerId) return;
    
    // Clean up previous connection
    cleanupSocket();
    
    currentPeerId = peerId;
    currentPeerData = peerData;
    unreadIds = [];
    
    // Clear previous messages
    messagesEl.innerHTML = '';
    
    // Update chat header with proper styling
    chatHeader.innerHTML = `
      <div class="chat-header-avatar">
        ${peerData.avatar ? `<a href="${peerData.profile_url || '#'}" target="_blank"><img src="${peerData.avatar}" alt="${peerData.name}" style="width:40px;height:40px;border-radius:50%;object-fit:cover;"></a>` : `<a href="${peerData.profile_url || '#'}" target="_blank"><div class="avatar-placeholder"><i class="bi bi-person-circle"></i></div></a>`}
      </div>
      <div class="flex-grow-1">
        <div class="fw-semibold text-dark">
          <a href="${peerData.profile_url || '#'}" target="_blank" style="text-decoration:none;color:inherit;">${peerData.name}</a>
          ${peerData.is_private ? '<i class="bi bi-shield-lock text-muted ms-2" title="Private messages"></i>' : ''}
        </div>
        <small class="text-muted">${peerData.role}</small>
      </div>
    `;
    
    // Check privacy and show appropriate input UI
    if (peerData.is_private && !peerData.can_message) {
      showPrivacyRestriction();
    } else {
      showNormalInput();
    }
    
    // Highlight selected contact
    selectContact(peerId);
    
    // Connect WebSocket with error handling
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    try {
      socket = new WebSocket(`${wsScheme}://${window.location.host}/ws/chat/${peerId}/`);
      
      socket.onopen = function() {
        console.log('WebSocket connection established');
      };
      
      socket.onmessage = function(e){
        try {
          const data = JSON.parse(e.data);
          if (data.type === 'chat_message') {
            const existingMessage = messagesEl.querySelector(`[data-message-id="${data.message.id}"]`);
            if (!existingMessage) {
              renderMessage(data.message);
              
              // Handle new message updates with enhanced logic
              handleMessageUpdate(data.message, false);
            }
          } else if (data.type === 'read_receipt') {
            updateReadReceipts(data.message_ids, data.reader_id);
            
            // Update navbar counter when messages are read
            if (data.reader_id == currentUserId) {
              refreshNavbarCounter();
            }
          } else if (data.type === 'error') {
            // Handle server-side errors
            if (data.error && data.error.includes('privacy')) {
              showPrivacyError('Message blocked due to privacy settings.');
            } else {
              showPrivacyError('Error sending message: ' + (data.error || 'Unknown error'));
            }
          }
        } catch (err) {
          console.error('Error processing WebSocket message:', err);
        }
      };
      
      socket.onerror = function(error) {
        console.error('WebSocket error:', error);
      };
      
      socket.onclose = function(e) {
        console.log('WebSocket connection closed:', e.code, e.reason);
        
        // Handle privacy violations
        if (e.code === 4001) {
          showPrivacyError('Cannot connect to this user due to privacy settings. You need to be connected to send messages.');
          // Reset chat state
          currentPeerId = null;
          currentPeerData = null;
          showEmptyState();
        }
        
        socket = null;
      };
      
    } catch (error) {
      console.error('Error creating WebSocket:', error);
    }
    
    // Fetch existing messages
    const currentUserRole = '{{ user.role }}' || 'entrepreneur';
    const endpoint = currentUserRole === 'investor' ? `/investor/messages/${peerId}/` : `/entrepreneur/messages/${peerId}/`;
    fetch(endpoint, {
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        }
    })
      .then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return r.json();
      })
      .then(d => {
        (d.messages||[]).forEach(m => {
          renderMessage(m);
          if (!m.is_read && String(m.sender) !== String(currentUserId)) {
            unreadIds.push(m.id);
          }
        });
        
        // Mark messages as read
        if (unreadIds.length && socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({action:'mark_read', message_ids: unreadIds}));
        }
        
        setUnreadBadge(peerId, 0);
        
        // Update last message preview for this user
        const lastMessage = d.messages && d.messages.length > 0 ? d.messages[d.messages.length - 1] : null;
        if (lastMessage) {
          const isFromMe = String(lastMessage.sender) === String(currentUserId);
          updateLastMessagePreview(peerId, lastMessage.content, isFromMe, lastMessage.timestamp);
        }
        
        // Restore unread counts for other conversations
        Object.keys(unreadCounts).forEach(userId => {
          if (userId != peerId && unreadCounts[userId] > 0) {
            setUnreadBadge(userId, unreadCounts[userId]);
          }
        });
        
        // Scroll to bottom with slight delay
        setTimeout(() => { 
          messagesEl.scrollTop = messagesEl.scrollHeight; 
        }, 100);
      })
      .catch(error => {
        console.error('Error fetching messages:', error);
        if (error.message && error.message.includes('403')) {
          messagesEl.innerHTML = '<div class="text-center text-muted py-4"><i class="bi bi-shield-lock fs-1 opacity-25"></i><div class="mt-2">This user has set their messages to private. You cannot send messages to them at this time. Any previous messages in this chat will remain hidden until the user allows messages again.</div>';
        } else {
          messagesEl.innerHTML = '<div class="text-center text-muted py-4"><i class="bi bi-exclamation-triangle fs-1 opacity-25"></i><div class="mt-2">Unable to load messages</div><div class="small">Please try again later.</div></div>';
        }
      });
    
    clearPreview();
  }

  // --- Media preview logic ---
  function showPreview(file) {
    previewFile = file;
    previewType = null;
    previewUrl = null;
    const chatInputPreview = document.getElementById('chatInputPreview');
    if (!chatInputPreview) return;
    
    chatInputPreview.innerHTML = '';
    
    if (!file) { 
      chatInputPreview.style.display = 'none'; 
      return; 
    }
    
    let type = 'document';
    if (file.type.startsWith('image/')) type = 'image';
    else if (file.type.startsWith('video/')) type = 'video';
    
    previewType = type;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      previewUrl = e.target.result;
      let html = '';
      
      if (type === 'image') {
        html = `<img src="${previewUrl}" alt="Preview">`;
      } else if (type === 'video') {
        html = `<video src="${previewUrl}" controls></video>`;
      } else {
        html = `<div class="d-flex align-items-center"><i class="bi bi-file-earmark me-2"></i> ${file.name}</div>`;
      }
      
      html += `<span class="preview-cancel" title="Remove">&times;</span>`;
      chatInputPreview.innerHTML = html;
      chatInputPreview.style.display = 'flex';
      
      const cancelBtn = chatInputPreview.querySelector('.preview-cancel');
      if (cancelBtn) {
        cancelBtn.onclick = clearPreview;
      }
    };
    
    reader.readAsDataURL(file);
  }
  
  function clearPreview() {
    previewFile = null; 
    previewType = null; 
    previewUrl = null;
    const chatInputPreview = document.getElementById('chatInputPreview');
    if (chatInputPreview) {
      chatInputPreview.innerHTML = '';
      chatInputPreview.style.display = 'none';
    }
    const fileInput = document.getElementById('chatFile');
    if (fileInput) fileInput.value = '';
  }

  // --- Chat message rendering with enhanced timestamps and read receipts ---
  function renderMessage(m) {
    // Prevent duplicate messages
    if (m.id && messagesEl.querySelector(`[data-message-id="${m.id}"]`)) return;
    
    // Correct alignment logic: sender == currentUserId (as string)
    const isMe = String(m.sender) === currentUserId;
    const bubble = document.createElement('div');
    // Proper class assignment for alignment
    bubble.className = 'bubble ' + (isMe ? 'sender' : 'receiver');
    if (m.id) {
      bubble.setAttribute('data-message-id', m.id);
    }
    
    // Handle different message types
    if (m.message_type === 'image' && m.file_base64) {
      bubble.innerHTML = `<img src="data:${m.file_type || 'image/jpeg'};base64,${m.file_base64}" alt="Image" style="max-width:250px;max-height:250px;display:block;border-radius:8px;">`;
    } else if (m.message_type === 'video' && m.file_base64) {
      bubble.innerHTML = `<video controls style="max-width:250px;max-height:200px;border-radius:8px;"><source src="data:${m.file_type || 'video/mp4'};base64,${m.file_base64}"></video>`;
    } else if (m.message_type === 'document' && m.file_name) {
      bubble.innerHTML = `<a href="data:${m.file_type};base64,${m.file_base64}" download="${m.file_name}"><i class="bi bi-file-earmark"></i> ${m.file_name}</a>`;
    } else {
      bubble.textContent = m.content || '';
    }
    
    // Enhanced timestamp and read receipt display
    const statusDiv = document.createElement('div');
    statusDiv.className = 'message-status';
    
    // Timestamp formatting
    const ts = m.timestamp ? new Date(m.timestamp) : null;
    let timeString = '';
    if (ts) {
      const now = new Date();
      if (now.toDateString() === ts.toDateString()) {
        // Today: show only time
        timeString = ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } else {
        // Not today: show date and time
        timeString = ts.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
    }
    
    // Enhanced WhatsApp-like read receipts
    if (isMe) {
      if (m.is_read) {
        statusDiv.innerHTML = `
          <span class="msg-time">${timeString}</span>
          <span class="read-tick read"><i class="bi bi-check2-all"></i></span>
        `;
      } else {
        statusDiv.innerHTML = `
          <span class="msg-time">${timeString}</span>
          <span class="read-tick"><i class="bi bi-check2"></i></span>
        `;
      }
    } else {
      statusDiv.innerHTML = `<span class="msg-time">${timeString}</span>`;
    }
    
    bubble.appendChild(statusDiv);
    messagesEl.appendChild(bubble);
    
    // Auto-scroll to bottom with smooth behavior
    requestAnimationFrame(() => {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
  }

  function updateReadReceipts(ids, readerId) {
    if (String(readerId) === String(currentUserId)) return;
    
    // Update all my sent messages to show as read
    const myMessages = messagesEl.querySelectorAll('.bubble.sender');
    myMessages.forEach(bubble => {
      const statusDiv = bubble.querySelector('.message-status');
      if (statusDiv) {
        const timeEl = statusDiv.querySelector('.msg-time');
        const timeText = timeEl ? timeEl.textContent : '';
        statusDiv.innerHTML = `
          <span class="msg-time">${timeText}</span>
          <span class="read-tick read"><i class="bi bi-check2-all"></i></span>
        `;
      }
    });
  }

  // --- Send message functionality ---
  function sendMessage() {
    if (!currentPeerId || !socket || socket.readyState !== WebSocket.OPEN) {
      console.warn('Cannot send message: no connection');
      return;
    }
    
    const inputEl = document.getElementById('chatInput');
    if (!inputEl) return; // Input might be hidden due to privacy
    
    // Frontend privacy validation
    if (currentPeerData && currentPeerData.is_private) {
      // Check if we have a connection with this user
      const hasConnection = canMessageUser(currentPeerData);
      if (!hasConnection) {
        showPrivacyError('This user has private messages. You need to be connected to send messages.');
        return;
      }
    }
    
    const text = inputEl.value.trim();
    
    if (previewFile) {
      const file = previewFile;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const base64 = e.target.result.split(',')[1];
          const messageData = {
            action: 'send_message',
            content: text || '',
            message_type: previewType,
            file_data: base64,
            file_name: file.name,
            file_type: file.type,
            file_size: file.size
          };
          socket.send(JSON.stringify(messageData));
          clearPreview();
          inputEl.value = '';
          
          // Update recent chats list to include this user if not already present
          updateRecentChatsList(currentPeerId, {
            ...currentPeerData,
            lastMessage: text || 'Sent a file',
            timestamp: new Date().toISOString()
          });
        } catch (error) {
          console.error('Error sending file:', error);
        }
      };
      reader.readAsDataURL(file);
    } else if (text) {
      try {
        socket.send(JSON.stringify({ 
          action: 'send_message', 
          content: text, 
          message_type: 'text' 
        }));
        inputEl.value = '';
        
        // Update recent chats list to include this user if not already present
        updateRecentChatsList(currentPeerId, {
          ...currentPeerData,
          lastMessage: text,
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('Error sending message:', error);
      }
    }
  }

  // --- Privacy validation helpers ---
  function showPrivacyError(message) {
    // Show privacy error message
    const errorDiv = document.createElement('div');
    errorDiv.className = 'alert alert-warning alert-dismissible fade show';
    errorDiv.innerHTML = `
      <i class="bi bi-shield-lock me-2"></i>
      ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    // Insert at the top of chat messages
    messagesEl.insertBefore(errorDiv, messagesEl.firstChild);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (errorDiv.parentNode) {
        errorDiv.remove();
      }
    }, 5000);
  }
  
  // --- Update recent chats list with new message ---
  function updateRecentChatsList(userId, userData) {
    // Check if user is already in recent list
    const existingItem = recents.querySelector(`[data-user-id="${userId}"]`);
    if (!existingItem) {
      // Create new recent item
      const newItem = document.createElement('div');
      newItem.className = 'recent-item';
      newItem.setAttribute('data-user-id', userId);
      
      const role = userData.role.toLowerCase();
      const profileUrl = role === 'investor' ? `/investor/profile/${userId}/` : `/entrepreneur/profile/${userId}/`;
      
      newItem.innerHTML = `
        ${userData.avatar ? `<a href="${profileUrl}" target="_blank"><img src="${userData.avatar}" class="avatar"></a>` : `<a href="${profileUrl}" target="_blank"><i class="bi bi-person-circle fs-4 avatar"></i></a>`}
        <div class="flex-grow-1">
          <div class="fw-semibold">
            <a href="${profileUrl}" target="_blank" style="text-decoration:none;color:inherit;">${userData.name}</a>
            ${userData.is_private ? '<i class="bi bi-shield-lock privacy-shield" title="Private messages"></i>' : ''}
          </div>
          <div class="small text-muted">${userData.role}</div>
          <div class="last-message-preview">
            ${userData.lastMessage ? '<i class="bi bi-check2"></i> ' + userData.lastMessage : ''}
          </div>
        </div>
        <span class="unread-badge" style="display:none;">0</span>
        <div class="last-message-time">${userData.timestamp ? formatMessageTime(userData.timestamp) : ''}</div>
      `;
      
      // Add click event listener to the new item
      newItem.addEventListener('click', function() {
        openChat(userId, {
          name: userData.name,
          avatar: userData.avatar,
          role: userData.role,
          profile_url: profileUrl,
          is_private: userData.is_private || false
        });
        selectContact(userId);
      });
      
      // Add to the beginning of the list
      recents.insertBefore(newItem, recents.firstChild);
      
      // Update the recentUsers array
      recentUsers.unshift({
        id: userId,
        name: userData.name.toLowerCase(),
        el: newItem
      });
    } else {
      // Update existing item
      updateLastMessagePreview(userId, userData.lastMessage, String(userId) === String(currentUserId), userData.timestamp);
    }
    
    // Sort chats by timestamp
    setTimeout(sortRecentChats, 100);
  }

  // --- Initialize empty state ---
  function showEmptyState() {
    chatHeader.innerHTML = `
      <div class="empty-chat">
        <i class="bi bi-chat-square-text"></i>
        <h5>Select a conversation</h5>
        <p class="mb-0">Choose from your existing conversations or search for someone to start a new chat.</p>
      </div>
    `;
    messagesEl.innerHTML = '';
  }
  
  // --- Cleanup on page unload ---
  window.addEventListener('beforeunload', cleanupSocket);
  
  // Check if we should open a specific chat from URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const openChatId = urlParams.get('open_chat');
  
  if (openChatId) {
    // Find the user in recent chats or search for them
    const recentItem = recents.querySelector(`[data-user-id="${openChatId}"]`);
    if (recentItem) {
      // User is in recent chats, open their chat
      const userId = openChatId;
      const role = recentItem.querySelector('.small.text-muted').textContent.toLowerCase();
      const profileUrl = role === 'investor' ? `/investor/profile/${userId}/` : `/entrepreneur/profile/${userId}/`;
      const isPrivate = recentItem.querySelector('.privacy-shield') !== null;
      
      openChat(userId, {
        name: recentItem.querySelector('.fw-semibold').textContent.replace(/\s*🔒/, '').trim(),
        avatar: recentItem.querySelector('img') ? recentItem.querySelector('img').src : null,
        role: recentItem.querySelector('.small.text-muted').textContent,
        profile_url: profileUrl,
        is_private: isPrivate
      });
      selectContact(userId);
      
      // Clear the URL parameter
      window.history.replaceState({}, document.title, window.location.pathname);
    } else {
      // User not in recent chats, search for them
      const currentUserRole = '{{ user.role }}' || 'entrepreneur';
      const searchEndpoint = currentUserRole === 'investor' ? `/investor/messages/search/` : `/entrepreneur/messages/search/`;
      fetch(`${searchEndpoint}?q=${openChatId}`)
        .then(r => r.json())
        .then(d => {
          const user = d.results.find(u => u.id == openChatId);
          if (user) {
            openChat(user.id, {
              name: user.name,
              avatar: user.avatar,
              role: user.role,
              profile_url: user.profile_url,
              is_private: user.is_private
            });
            selectContact(user.id);
            
            // Clear the URL parameter
            window.history.replaceState({}, document.title, window.location.pathname);
          } else {
            showEmptyState();
          }
        })
        .catch(() => {
          showEmptyState();
        });
    }
  } else if (!currentPeerId) {
    // Show empty state initially if no chat is selected
    showEmptyState();
  }
  
  // --- Enhanced responsive behavior ---
  function handleResize() {
    if (messagesEl.scrollHeight > messagesEl.clientHeight) {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
  }
  
  window.addEventListener('resize', handleResize);
  
  // --- Auto-focus input when chat is opened ---
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.target === chatHeader && currentPeerId) {
        const inputEl = document.getElementById('chatInput');
        if (inputEl) {
          setTimeout(() => inputEl.focus(), 100);
        }
      }
    });
  });
  
  observer.observe(chatHeader, { childList: true });
  
  // Sort recent chats on initial load
  setTimeout(sortRecentChats, 100);
  
  // Initialize the messaging system
  initializeMessagingSystem();
  
})();
</script>
{% endblock %}